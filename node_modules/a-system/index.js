/**
 * Парсинг заказа из ASystem в текстовом формате
 * 
 * @param {string} text
 * @return {object}
 */
exports.parseOrder = function(text) {
  /**
   * @todo i18n
   */
  var ERR_PARSE = 'ОШИБКА ПАРСИНГА';

  /**
   * В бой вступают регулярки
   * 
   * Интерфейс объектов парсера:
   * 
   * @param {string} field Имя поля в результирующем объекте;
   * @param {RegExp} matcher Регулярка, определяющая значение;
   * @param {number} [index] Индекс значения в массиве совпадений, опционально;
   * @param {function} [postProcess] Пост-обработка значения, опционально;
   */
  var parser = [{
    field: 'order_number', // Номер заказа
    matcher: /\d{3}.\d{5}/,
    index: 0
  }, {
    field: 'customer', // Заказчик
    matcher: /Технолог:\.*\s{2}(.*)/
  }, {
    field: 'order_name', // Наименование заказа
    matcher: /\/ ([^\n\n]*)/,
    postProcess: function(m) {
      // С выходным значением ничего не делаем...
      return m;
      // ...хотя можно что угодно, например:
      //return m.split(', ');
      //return m.toUpperCase();
      //return m.replace(/ /g,'_');
    }
  }, {
    field: 'manager', // Менеджер
    matcher: /Менеджер: (.*)/
  }, {
    field: 'master', // Технолог
    matcher: /Технолог: (.*)/
  }, {
    field: 'designer', // Дизайнер
    matcher: /КАРТА\n{2}Тафлекс ООО\n{2}(.*)/
  }, {
    field: 'profile', // Цветовой профиль
    matcher: /\d{3}.\d{5}\n{2}(.*)/,
    postProcess: function(m) {
      return m.replace(/\s+/g, '');
    }
  }, {
    field: 'cut_type', // Тип высечки
    matcher: /Высечка ([^\s]*)/
  }, {
    field: 'cut_number', // Номер высечки
    matcher: /.*/
  }, ];

  var result = {};

  parser.forEach(function(p) {
    var m = p.matcher.exec(text);

    // Индекс совпадения, по умолчанию 1
    var r = (typeof(p.index) === 'undefined') ? 1 : p.index;

    // Пост-обработка, если требуется
    // С отловом ошибок парсинга
    var value;
    try {
      value = m[r];
      if (typeof(p.postProcess) === 'function') {
        value = p.postProcess(m[r]);
      }
    } catch (e) {
      value = ERR_PARSE;
    }

    result[p.field] = value;
  });

  return result;
};

'use strict';

var _ = require('lodash');

var PDFParser = require('pdf2xml'),
  XMLParser = require('xml2js');

var fs = require('fs');

/**
 * Парсинг заказа из ASystem в формате JSON
 * 
 * @param {string|object} data
 * @return {object}
 */
exports.parseJsonOrder = function(text) {
  /**
   * Стринг в качестве параметра тоже принимаем
   */
  if (typeof(text) === 'string') {
    text = JSON.parse(text);
  }

  var matchers = {
    /**
     * Дизайнера ищем во второй строчке первой страницы
     */
    designer: {
      matcher: /.*/,
      postProcess: function(params) {
        if (params.pageNumber === 0 && params.lineNumber === 1) {
          return params.result[0];
        }
      }
    },
    /**
     * 
     */
    order_name: {
      matcher: /Заказ №/,
      postProcess: function(params) {
        var startFrom = text[params.pageNumber][params.lineNumber][2];
        var value = multiLineMatch(startFrom, text, params);
        // Открыжим название заказа
        var from = value.lastIndexOf('/') + 1;
        return value.substring(from).replace(/ +/g, ' ').trim() || 'ООО Криворуков';
      }
    },
    order_number: {
      matcher: /Заказ №/,
      isValid: function(value) {
        return (value.match(/\d{3}[А-Я]\d{5}/)) ? true : false;
      }
    },
    master: {
      matcher: /Технолог:/
    },
    manager: {
      matcher: /Менеджер:/
    },
    customer: {
      matcher: /Заказчик:/
    },
    printing: {
      matcher: /Тираж:/,
      idValid: function(value) {
        return (value.match(/\d+/)) ? true : false;
      }
    },
    profile: {
      matcher: /Применить профиль/,
      postProcess: function(p) {
        var startFrom = text[p.pageNumber][p.lineNumber][p.chunkIndex + 1];
        var value = multiLineMatch(startFrom, text, p);
        return value;
      }
    },
    cut_type: {
      matcher: /^Высечка$/
    },
    /**cut_number: {
      matcher: /Используемые инструменты ?/
    }*/
  };

  /**
   * Создадим эталонный объект заказа из полей матчера и заполнять будем его
   * Так поля, которые не спарсились, автоматом станут null
   */
  var order = _.assign({}, matchers, () => { return null; } );
  
  //var started = new Date().getTime(); // benchmarks
  
  /**
   * Основной цикл
   */
  _.forEach(text, (page, pind) => {
    _.forEach(page, (line, lind) => {
      _.forEach(line, (chunk, cind) => {
        if (_.isUndefined(chunk.txt)) {
          //console.warn(`Empty text block at ${lind}:${cind}`);
          return;
        }
        
        /**if (chunk.txt === "Заказчик: ") {
          debugger;
        }*/
        
        /**
         * По матчерам идем справа-налево (или снизу вверх если на код смотреть)
         * потому что собираюсь "стрелянные" матчеры выкидывать из набора. Когда
         * направление справа-налево, такие вещи можно творить безнаказанно.
         */
        _.forEachRight(matchers, (m, key, collection) => {
          var anchor = chunk.txt.match(m.matcher);
          if (anchor) {
            var processed;
            if (_.isFunction(m.postProcess)) {
              processed = m.postProcess({
                'result': anchor,
                'field': key,
                'pageNumber': pind,
                'lineNumber': lind,
                'chunkIndex': cind,
                'self': chunk
              });
            } else {
              /**
               * Обработчик по умолчанию: берем следующее за матчером значение
               */
              var next = line[cind + 1];
              if (!_.isUndefined(next) && next.font !== chunk.font) {
                processed = next.txt;
              }
            }
            if (processed) {
              if (_.isFunction(m.isValid) && !m.isValid(processed)) {
                order[key] = 'PARSING ERROR';
              } else {
                order[key] = processed;
                /**
                 * Матчер сделал свое дело, удалим его из набора, чтобы не 
                 * гонять лишних циклов. Возвращаем false чтоб немедленно
                 * выйти из текущего цикла.
                 */
                delete collection[key];
                return false;
              }
            }
          }
        })
      });
    });
  });
  
  //order.elapsed = new Date().getTime() - started; // benchmarks
  
  return order;
};

/**
 * Цепочка преобразований PDF->XML->JSON->JSON
 * 
 * Самое то место, где можно подсмотреть:
 * * какой получается XML из PDF после poppler pdftohtml;
 * * какой получается JSON их XML после xml2js;
 * * что получается после наших преобразований;
 * Раскомментируй fs.writeFileSync и смотри на здоровье
 * 
 * @param {string} filename
 * @return {Promise}
 */
exports.pdf2json = function(filename) {
  return new Promise(function(resolve, reject) {
    var pdfParser = new PDFParser(filename);
    var xml = pdfParser.getXMLSync();
    //fs.writeFileSync(`debug.xml`, xml);
    XMLParser.parseString(xml, function(err, data) {
      if (err) {
        reject(err);
      }
      //fs.writeFileSync(`debug-preHandle.json`, JSON.stringify(data, null, '\t'));
      var result = handleJSON(data);
      //fs.writeFileSync(`debug-postHandle.json`, JSON.stringify(result, null, '\t'));
      resolve(result);
    });
  });
}

/**
 * Преобразования из json от xml2js в json для asystem
 * 
 * @param {object} pdf Выхлоп xml2js
 * @return {object}
 */
function handleJSON(pdf) {
  if (_.isUndefined(pdf.pdf2xml)) {
    return;
  }
  var hereData = [];
  var researchFields = []; // debug only
  /**
   * Двигаем по страницам
   */
  _.forEach(pdf.pdf2xml.page, function(page, pind) {
    var pageContent = [];
    _.forEach(page.text, function(txt, tind) {
      // debug
      researchFields.push({
        field: _.keys(txt).sort().join(' '),
        pos: [pind, tind]
      });
      // end debug
      var content = txt._ || txt.b;
      if (_.isArray(content)) {
        content = content.join(' ');
      }
      pageContent.push({
        'x': txt.$.left,
        'y': txt.$.top,
        'w': txt.$.width,
        'h': txt.$.height,
        'txt': content,
        'font': txt.$.font || '#bacbac',
        // debug
        'page': pind,
        'index': tind
      });
    });
    /**
     * Группировка и нормализация строк на странице
     */
    var lines = _.chain(pageContent)
      /**
       * Группировка текстовых блоков в строки по координате у +/- 2 пункта
       * @todo Зависит от размера кегля, тут надо будет привязаться к шрифту
       */
      .groupBy(line => {
        return (line.y / 4.35) >> 0;
      })
      /**
       * Сортировка строк по y, т.е. чтоб шли сверху вниз
       */
      .sortBy((l, key) => {
        return parseFloat(key);
      })
      /**
       * Сортировка содержимого строк по х, т.е. слева направо
       */
      .map(line => {
        return _.sortBy(line, ch => {
          return parseFloat(ch.x);
        });
      })
      .value();

    hereData.push(lines);
  });

  /** debug
  var fieldsFound = _.chain(researchFields)
    .groupBy('field')
    .map((v, k) => {
      return {
        field: k,
        count: v.length,
        entry: _.map(v, 'pos')
      };
    }).value();
  fs.writeFileSync(`debug-preFields.json`, JSON.stringify(fieldsFound, null, '\t'));
  // end debug */

  return hereData;
}

/**
 * Сборка строк "в колонке"
 * 
 * @param {object} from Текстовый блок, к которому присобачивать висячки
 * @param {object} text Ссылка на исходный текст, который сейчас парсится
 * @param {object} params Контекст парсера (номер текущей страницы, строки, ...)
 * @return {string}
 */
function multiLineMatch(from, text, params) {
  var value = from.txt,
    nextLine = params.lineNumber + 1,
    feedY = parseInt(from.y),
    notYet = false;
  do {
    var nexts = _.filter(text[params.pageNumber][nextLine], chunk => {
      return chunk.x >= from.x;
    });
    var nextPosY = feedY + parseInt(from.h);
    notYet = false;
    _.forEach(nexts, str => {
      if ((parseInt(str.y) - nextPosY) <= 2 && str.font === from.font) {
        value += str.txt;
        feedY += from.h;
        nextLine++;
        notYet = true;
      }
    });

  } while (notYet);
  
  return value;
}